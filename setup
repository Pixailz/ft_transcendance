#!/bin/bash -eu

# CONFIG
## ENV
ENV_FILE="./.env"
VAR_TO_EDIT=(
	"ADMIN_USER"
	"ADMIN_PASS"
	"API42_USERID"
	"API42_SECRET"
	"API42_REDIRECTURL_PROD"
	"API42_REDIRECTURL_DEV"
)
JWT_LEN="64"

## ANGULAR ENV
ANGULAR_ENV_DIR="src/angularjs/src/app/environments"
ANGULAR_PROD_ENV="${ANGULAR_ENV_DIR}/environment.common.ts"
ANGULAR_DEV_ENV="${ANGULAR_ENV_DIR}/environment.dev.ts"

# FUNCTIONS
## ENV FUNCTION
function	install::env::replace_var()
{
	local	var_name="${1?}"
	local	var_value="${2?}"

	sed -i "s|${var_name}=\"\"|${var_name}=\"${var_value}\"|g" "${ENV_FILE}"
}

function	install::env()
{
	cp "${ENV_FILE}"{.template,}

	for var_name in ${VAR_TO_EDIT[@]}; do
		printf "\x1b[31m%s\x1b[00m > " "${var_name}"
		read choice
		install::env::replace_var "${var_name}" "${choice}"
	done

	JWT_PASS="$(head -c${JWT_LEN} /dev/urandom | xxd -ps -c ${JWT_LEN})"
	install::env::replace_var "JWT_SECRET" "${JWT_PASS}"
}

## ANGULAR FUNCTION
function	url::encode()
{
	local	url="${1?}"
	local	url_len="${#url}"

	url_encoded="$(
		for ((i = 0; i < url_len; i++)); do
			local	c="${url:${i}:1}"
			case "${c}" in
				[a-zA-Z0-9.~_-]) printf "%c" "${c}" ;;
				*) printf "%%%02X" "'${c}" ;;
			esac
		done
	)"
}

function	angular::env::replace_var()
{
	local	var_value="${1?}"
	local	file_path="${2?}"
	local	var="	after_auth_uri: "

	perl -pi -e "s|^${var}\".*?\"|${var}\"${var_value}\"|" "${file_path}"
}

function	angular::get_after_auth()
{
	local	var_name="${1?}"
	local	user_id
	local	redirect

	source "${ENV_FILE}"; \
		user_id="${API42_USERID}" \
		redirect="${!var_name}"
	url::encode "${redirect}"
	redirect="${url_encoded}"
	AFTER_AUTH="https://api.intra.42.fr/oauth/authorize?client_id=${user_id}"
	AFTER_AUTH+="&redirect_uri=${redirect}&response_type=code"
}

function	angular::set_after_auth()
{
	angular::get_after_auth "API42_REDIRECTURL_PROD"
	angular::env::replace_var "${AFTER_AUTH}" "${ANGULAR_PROD_ENV}"
	angular::get_after_auth "API42_REDIRECTURL_DEV"
	angular::env::replace_var "${AFTER_AUTH}" "${ANGULAR_DEV_ENV}"
}

## DOCKER
function	docker::kill()
{
	for file in ${KNOWN_FILE[@]}; do
		docker compose -f "./${file}" kill -s SIGINT
		docker compose -f "./${file}" down --rmi all
	done
}

function	docker::clean()
{
	sudo rm -rf ./src/angularjs/node_modules
	sudo rm -rf ./src/nestjs/node_modules
	sudo rm -rf ./volume
}

function	docker::re()
{
	local	mode="${1?}"
	local	do_clean="${2:-0}"
	local	file

	docker::kill
	[ "${do_clean}" == "0" ] || docker::clean
	docker compose -f "${KNOWN_FILE[${mode}]}" up --build
}

# PARSING
function	usage()
{
	printf "${0}: [re prod|dev] | [clean] | [switch]\n"
	printf "\tif no arg provided setup .env file\n"
	printf "\t\n"

	printf "\t\n"
	printf "\t\tre:     relaunch in dev or prod mode\n"
	printf "\t\tswitch: remove database and relauch in dev or prod mode\n"
	printf "\t\tclean:  down all service in compose and remove volume\n"
	exit 1
}
set -u
function	parse::re()
{

	[ "${ARGS_LEN}" != "2" ] && usage
	do_clean="1"

	case "${ARGS[1]}" in
		"re")
			do_clean="1"
		;;
		"switch")
			do_clean="0"
		;;
	esac
	angular::set_after_auth
	docker::re "${ARGS[1]}" "${do_clean}"
	unset do_clean
}

function	parse::arg()
{
	if [ "${ARGS_LEN}" -eq 0 ]; then
		install::env
		angular::set_after_auth
		return
	fi
	case "${ARGS[0]}" in
		"re"|"switch")
			parse::re
		;;
		"clean")
			docker::clean
		;;
		*) usage ;;
	esac
}

ARGS=(${@})
ARGS_LEN="${#ARGS[@]}"

declare -A KNOWN_FILE

KNOWN_FILE[dev]="docker-compose-dev.yaml"
KNOWN_FILE[prod]="docker-compose.yaml"

parse::arg

exit $?
